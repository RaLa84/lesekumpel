<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deine Geschichte</title>
    <style>
        /* --- GRUNDLAGEN --- */
        body { font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif; background-color: #f0f8ff; margin: 0; padding: 20px; color: #333; }
        .container { max-width: 800px; margin: 0 auto; background: #ffffff; padding: 40px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); border: 5px solid #ffcc00; }

        /* --- TOOLBAR --- */
        .toolbar { background-color: #fff9e6; border-radius: 15px; padding: 10px; margin-bottom: 30px; display: flex; justify-content: center; flex-wrap: wrap; gap: 10px; border: 2px dashed #ffcc00; }
        .tool-btn { background: white; border: 2px solid #ffcc00; border-radius: 10px; padding: 10px 15px; cursor: pointer; font-family: inherit; font-weight: bold; font-size: 16px; color: #555; display: flex; align-items: center; gap: 5px; transition: all 0.1s; user-select: none; -webkit-tap-highlight-color: transparent; }
        .tool-btn:hover { background-color: #ff6b6b; border-color: #ff6b6b; color: white; transform: translateY(-2px); }
        .tool-btn.active { background-color: #ffcc00; color: #333; border-color: #e6b800; box-shadow: inset 0 2px 5px rgba(0,0,0,0.1); }

        /* --- SILBEN STYLES --- */
        /* Standard: Farbe erben (Schwarz/Grau) */
        .syl { transition: color 0.2s; }
        
        /* Wenn Silben-Modus AN ist: Blau/Rot */
        .syllable-mode .syl-odd { color: #007bff; } /* Blau */
        .syllable-mode .syl-even { color: #d32f2f; } /* Rot */

        /* --- LUPE / INTERACTIVE STYLES --- */
        .interactive-word { display: inline-block; border-radius: 4px; transition: background 0.1s; border-bottom: 2px solid transparent; }
        
        /* Lupe AN Hover */
        .magnify-mode .interactive-word { cursor: pointer; }
        .magnify-mode .interactive-word:hover { background-color: rgba(255, 204, 0, 0.3); }

        /* Wort wird vorgelesen */
        .word-reading {
            background-color: #ffcc00 !important;
            color: #d32f2f !important;
            box-shadow: 0 0 0 4px #ffcc00; /* Dickerer Rahmen */
            border-radius: 4px;
            z-index: 10; position: relative;
        }
        /* Wenn wir lesen, √ºberschreiben wir die Silbenfarben tempor√§r */
        .word-reading .syl { color: #d32f2f !important; }

        /* --- INHALT --- */
        h1 { color: #ff6b6b; text-align: center; font-size: 2.5em; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 2px; }
        #story-content { font-size: 1.2em; line-height: 1.8; color: #555; transition: font-size 0.2s; }
        p { margin-bottom: 20px; }
        strong { color: #2c3e50; background-color: #fff3cd; padding: 0 4px; border-radius: 4px; }
        
        .story-image { display: block; margin: 20px auto 40px auto; width: 100%; max-width: 400px; height: auto; border-radius: 15px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); object-fit: contain; }
        .footer { margin-top: 60px; padding-top: 30px; border-top: 3px dashed #ffcc00; text-align: center; font-size: 1em; color: #888; }
        .footer a { color: #888; text-decoration: none; font-weight: bold; margin: 0 10px; }
        .separator { color: #ffcc00; font-weight: bold; }
    </style>
</head>
<body>

    <div class="container">
        <div class="toolbar">
            <button class="tool-btn" id="btnSyllables">üî¥üîµ Silben</button>
            <button class="tool-btn" id="btnMagnify">üîç Lupe</button>
            <button class="tool-btn" id="btnSpeak">üîä Vorlesen</button>
            <button class="tool-btn" id="btnSmaller">üÖ∞Ô∏è -</button>
            <button class="tool-btn" id="btnBigger">üÖ∞Ô∏è +</button>
        </div>

        <div id="story-content" lang="de">
            
<h1>Das warme Geheimnis im Br√∂tchenbett</h1><img src="../bilder/das-warme-geheimnis-im-broetchenbett.png" onerror="this.onerror=null;this.src='https://rala84.github.io/lesekumpel/bilder/lesekumpel_logo.png';" class="story-image" alt="Geschichten Bild">

Stell dir vor, du h√§ltst etwas Warmes in deinen H√§nden. Es riecht so verlockend ‚Äì nach etwas Herzhaftem, aber auch ganz leicht nach weichem Brot. Ein runder Br√∂tchendeckel liegt da, so sanft wie eine frisch gebackene Wolke, und darauf tanzen winzige Sesamk√∂rner wie kleine, goldene Sternchen.

Darunter verbirgt sich eine Welt: saftiges, warmes Fleisch, und dar√ºber schmilzt K√§se wie eine goldene Decke. Ein knackiges Salatblatt lugt hervor, frisch und gr√ºn wie ein Fr√ºhlingsmorgen. Wenn du ganz vorsichtig hineinbei√üt... sp√ºrst du, wie alles zusammenkommt? Die weiche Br√∂tchenwolke, das w√ºrzige Herz, das frische Gr√ºn. Ein kleiner Augenblick Gl√ºck, der auf der Zunge zergeht.
        </div>
        
        <div class="footer">
            <p>Erstellt von deinem KI-Lesekumpel ü§ñ</p>
            <div style="margin-top: 10px;">
                <a href="https://rala84.app.n8n.cloud/form/30d75a75-54fd-42fd-bea6-ab24799ca565">‚ú® Neue Geschichte</a>
                <span class="separator">|</span>
                <a href="../index.html">üìö Zur Bibliothek</a>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener("DOMContentLoaded", function() {
        const content = document.getElementById('story-content');
        let currentSize = 1.2;
        let isSpeaking = false;
        let isMagnifyMode = false;
        let isSyllableMode = false;
        let textProcessed = false; // Merkt sich, ob wir den Text schon zerlegt haben

        // --- 1. SILBEN-ALGORITHMUS (Die Magie) ---
        function getSyllables(word) {
            // Einfacher Heuristik-Algorithmus f√ºr Deutsche Silben
            // 1. Wir definieren Vokale und "feste" Cluster, die nicht getrennt werden
            const vowels = /[aeiouy√§√∂√º]+/i;
            
            // Wir zerlegen das Wort St√ºck f√ºr St√ºck
            // Regex Erkl√§rung: Finde Vokale, gefolgt von Konsonanten, bis zum n√§chsten Vokal
            // Das ist komplex, daher nutzen wir eine Ann√§herung:
            // Wir splitten VCV (Vokal-Konsonant-Vokal) -> V-CV
            // Wir splitten VCCV (Vokal-Konsonant-Konsonant-Vokal) -> VC-CV
            // Aber: sch, ch, ck, ph, th, st bleiben oft zusammen oder haben Sonderregeln.
            
            // Wir nutzen hier einen robusten "Pattern-Matcher", der f√ºr Leseanf√§nger gut genug ist:
            
            let parts = [];
            let tempWord = word;
            
            // Ein sehr vereinfachter Splitter (funktioniert gut f√ºr die visuelle Hilfe):
            // Wir teilen vor Konsonanten-Vokal Mustern, beachten aber Cluster.
            
            // Wir markieren erst Cluster, damit sie nicht getrennt werden
            tempWord = tempWord.replace(/(sch|ch|ck|ph|th|qu)/gi, (m) => m.toUpperCase()); // Tempor√§r sch√ºtzen
            
            // Jetzt teilen wir: Vokal gefolgt von einzelnem Konsonant -> Trennung davor
            // Regex: Vokal + (evtl Konsonant) + Vokal...
            
            // Da JS Regex kein Lookbehind in allen Browsern kann, machen wir es per Loop:
            // Wir nutzen eine bew√§hrte einfache Logik f√ºr Client-Side JS:
            const pattern = /[^aeiouy√§√∂√º]*[aeiouy√§√∂√º]+(?:[^aeiouy√§√∂√º]*$|[^aeiouy√§√∂√º](?=[^aeiouy√§√∂√º]))?/gi;
            
            // Pattern Match
            let match;
            // Wir m√ºssen das gesch√ºtzte Wort nutzen
            // Aber der Matcher muss Case-Insensitive sein f√ºr die Vokale
            // Wir machen es einfacher: Wir nutzen eine Library-√§hnliche Funktion direkt hier:
            
            return visualSyllabify(word);
        }
        
        function visualSyllabify(word) {
            // Eine robuste Funktion, die versucht, deutsch zu trennen
            if (word.length < 3) return [word];
            
            // Wir f√ºgen Trennzeichen ein
            let w = word;
            
            // Schritt 1: Vokal-Konsonant-Vokal -> Vokal - Konsonant-Vokal (le-sen)
            // Wir nutzen $1-$2. Aber wir m√ºssen Cluster sch√ºtzen.
            // Cluster: sch, ch, ph, th, sh. (ck trennt man im neuen Deutsch nicht mehr, also k-k? Nein ck bleibt zusammen)
            
            // Platzhalter f√ºr Cluster einsetzen
            w = w.replace(/sch/gi, '###');
            w = w.replace(/ch/gi, '##');
            w = w.replace(/ck/gi, '@@'); // Bleibt zusammen
            w = w.replace(/ph/gi, '%%');
            w = w.replace(/th/gi, '&&');
            
            // Hauptregel: Vokal - Einzelner Konsonant - Vokal
            w = w.replace(/([aeiouy√§√∂√º])([^aeiouy√§√∂√º#@%&])([aeiouy√§√∂√º])/gi, '$1|$2$3');
            
            // Regel 2: Vokal - Konsonant - Konsonant - Vokal -> Vokal Konsonant - Konsonant Vokal
            w = w.replace(/([aeiouy√§√∂√º])([^aeiouy√§√∂√º#@%&|])([^aeiouy√§√∂√º#@%&|])([aeiouy√§√∂√º])/gi, '$1$2|$3$4');
            
            // Platzhalter zur√ºcktauschen
            w = w.replace(/###/g, 'sch');
            w = w.replace(/##/g, 'ch');
            w = w.replace(/@@/g, 'ck');
            w = w.replace(/%%/g, 'ph');
            w = w.replace(/&&/g, 'th');
            
            return w.split('|');
        }


        // --- 2. HTML UMBAUEN (Einmalig) ---
        function processText() {
            if (textProcessed) return;

            // Wir suchen alle Textbl√∂cke
            const blocks = content.querySelectorAll('p, li');
            
            blocks.forEach(block => {
                const nodes = Array.from(block.childNodes);
                nodes.forEach(node => {
                    if (node.nodeType === 3) { // Text Node
                        const text = node.nodeValue;
                        if (!text.trim()) return;

                        // Wir bauen HTML: Jedes Wort in ein Span, darin Silben-Spans
                        const fragment = document.createDocumentFragment();
                        
                        // Text an Leerzeichen splitten, aber Satzzeichen behalten
                        // Wir splitten einfach alles
                        const words = text.split(/([ \t\n\r,.!?;:()"]+)/);
                        
                        words.forEach(chunk => {
                            if (!chunk) return;
                            
                            // Ist es ein Wort? (Enth√§lt Buchstaben)
                            if (/[a-zA-Z√§√∂√º√Ñ√ñ√ú√ü]/.test(chunk)) {
                                const wordSpan = document.createElement('span');
                                wordSpan.className = 'interactive-word';
                                wordSpan.innerText = chunk; // Fallback
                                
                                // Silben berechnen
                                const syllables = getSyllables(chunk);
                                
                                // Wenn wir Silben haben, bauen wir sie ein
                                if (syllables.length > 0) {
                                    wordSpan.innerHTML = ''; // Text leeren
                                    syllables.forEach((syl, index) => {
                                        const sSpan = document.createElement('span');
                                        sSpan.className = 'syl ' + (index % 2 === 0 ? 'syl-odd' : 'syl-even');
                                        sSpan.innerText = syl;
                                        wordSpan.appendChild(sSpan);
                                    });
                                }